
Ключове слово volatile
==========================

Ключове слово volatile використовується для
позначення змінної як "що зберігається в основній
пам'яті".
Точніше, це означає, що кожне читання volatile-змінної
буде зчитуватися з основної пам'яті комп'ютера, а не з
кешу ЦП, і що кожен запис у volatile-змінний записуватиметься
в оперативну пам'ять, а не лише в кеш ЦП.

У багатопотоковому додатку, де потоки працюють з
енергонезалежними змінними, кожен потік може копіювати
змінні з основної пам'яті в кеш ЦП під час роботи з ними
з міркувань продуктивності.
Якщо комп'ютер містить більше одного ЦП, кожен потік може
виконуватися на іншому ЦП. Це означає, що кожен потік може
копіювати змінні у кеш ЦП різних ЦП.

З енергонезалежними змінними немає жодних гарантій щодо того,
коли віртуальна машина Java (JVM) зчитує дані з основної
пам'ятів кеші ЦП або записує дані з кешів ЦП в пам'ять.

Використання volatile – це ще один спосіб (як і synchronized)
зробити клас потокобезпечним.

Ключове слово volatile використовується для зміни значення
змінної різними потоками. Воно також використовується для
забезпечення потокобезпеки класів.

Це означає, що кілька потоків можуть без проблем
використовувати метод та екземпляр класів одночасно.

Ключове слово volatile може використовуватися як з
примітивним типом, і з об'єктами.

Ключове слово volatile не кешує значення змінної і завжди
зчитує змінну із основної пам'яті.

Ключове слово volatile не можна використовувати з класами
чи методами.
Однак воно використовується зі змінними. Це також гарантує
видимість та порядок. Це запобігає перевпорядкуванню коду
компілятором.

Вміст конкретного регістру пристрою може змінитися будь-коли,
тому потрібно ключове слово volatile, щоб гарантувати,
що такі перетворення не буде оптимізовано компілятором.

--------------------------------------------------

class Demo {
     static int value = 3;
}

У наведеному вище прикладі припустимо, що два потоки
працюють над одним і тим самим класом.

Обидва потоки виконуються на різних процесорах, де кожен
потік має свою локальну копію значення.

Якщо будь-який потік змінить своє значення, ця зміна
не відобразиться на вихідному значенні в основній пам'яті.

Це призводить до неузгодженості даних, оскільки інший потік
не знає про змінене значення.


class Demo {
     static volatile int value = 3;
}

Статичні змінні є членами класу, які є спільними
для всіх об'єктів. В основній пам'яті лише одна копія.

Значення volatile змінної ніколи не буде збережено у кеші.

Всі операції читання та запису будуть виконуватися з
основної пам'яті та до неї.

--------------------------------------------------

КОЛИ використовувати volatile?

Можете використовувати volatile змінну, якщо хочете
автоматично читати та записувати long та double змінну.

Можна використовувати як альтернативний спосіб досягнення
синхронізації у Java.

Всі потоки читання побачать оновлене значення volatile
змінної після завершення операції запису. Якщо ви не
використовуєте ключове слово volatile, різні потоки читання
можуть бачити різні значення.

Використовується для інформування компілятора про те, що
кілька потоків звертатимуться до певного оператора.
Це не дозволяє компілятору виконувати якесь переупорядкування
чи оптимізацію.

Якщо не використовуєте змінну volatile, компілятор може
переупорядкувати код, вільно записуючи в кеш значення
volatile змінної замість читання із основної пам'яті.

--------------------------------------------------

Happens-Before (відбувається до)

Java volatile дає гарантію «відбувається до».
Це гарантує, що:

Читання та запис в інші змінні не можна переупорядкувати так,
щоб вони відбувалися після запису в volatile змінну, якщо
читання/запис спочатку відбувалися до запису в volatile змінну.
Читання/запис перед записом у volatile змінну гарантовано
«відбувається до» запису в volatile змінну.
Зверніть увагу, що це все ще можливо, наприклад, читає/записує
інші змінні, розташовані після запису в volatile, щоб
переупорядкувати їх, щоб вони відбувалися до цього запису
в volatile.
Тільки не навпаки. Від «після» до «до» дозволено, але від
«до» до «після» не допускається.

Читання та запис в інші змінні не можуть бути переупорядковані
так, щоб вони відбувалися до читання volatile змінної, якщо
операції читання/запису спочатку відбувалися після читання
volatile змінної.
Зверніть увагу, що читання інших змінних, яке відбувається до
читання volatile-змінної, може бути переупорядковано після
читання volatile-змінної.
Тільки не навпаки. Від «до» до «після» дозволено, але від
«після» до «до» не дозволено.

--------------------------------------------------

РІЗНИЦЯ між синхронізацією та ключовим словом volatile

Ключове слово volatile є модифікатором поля.
Ключове слово synchronized змінює блоки коду та методи.

volatile. Потік не може бути заблокований для очікування
у випадку нестабільності.
synchronized. Потоки можуть бути заблоковані для очікування
у випадку синхронізації.

volatile покращує продуктивність потоку.
synchronized. Синхронізовані методи знижують продуктивність
потоку.

volatile синхронізує значення однієї змінної за раз між
пам'яттю потоку та основною пам'яттю.
synchronized синхронізує значення всіх змінних між пам'яттю
потоку та основною пам'яттю.

volatile поля не підлягають оптимізації компілятором.
Синхронізація підлягає оптимізації компілятором.

