
Synchronizers (Синхронізатори) Java
=======================================

В Java, шляхом СПІЛЬНОГО ДОСТУПУ до полів та об'єктів, досягається зв'язок
потоків. Взаємодія потоків і несуперечність пам'яті - деякі з ПРОБЛЕМ, що
виникають через взаємодію потоків. Ці проблеми можна вирішити за допомогою
синхронізації.

Однак ЗАТРИМКА може бути викликана синхронізацією при доступі до блокування
або об'єкту, який в даний момент утримується іншим потоком. ПОКИ інший потік
не зніме блокування об'єкта, потік, що очікує НЕ МОЖЕ використовувати цей об'єкт.
Цей стан називається конфліктом потоків.


Java надає класи для загальної синхронізації спеціального призначення (допоміжні
утиліти для синхронізації потоків) - синхронізатори (synchronizers).
Пакет java.util.concurrent.

Class Semaphore (Семафор)
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html
Щоб обмежити доступ потоку до певного ресурсу, використовується семафор.
Ряд дозволів потоку ініціюється під час створення об'єкта семафора.
До тих пір, поки ЛІЧИЛЬНИК ДОЗВОЛІВ не стане більше нуля, метод отримання
блокується та приймає його, якщо він доступний, та зменшує лічильник дозволів.
Для звільнення блокуючого потоку використається метод release.

Class CountDownLatch (Клямка зворотного відліку)
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html
У Class CountdownLatch один або кілька потоків налаштовані на ОЧІКУВАННЯ
завершення набору операцій в інших потоках. Ініціалізується кількість потоків
для встановлення очікування. Поки лічильник не досягне нуля, метод очікування
блокується.

Class CyclicBarrier (Циклічний бар'єр)
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html
Class CyclicBarrier застосовує КОНЦЕПЦІЮ СТОРІН. Поки не буде досягнуто
загальної точки бар'єра, це дозволяє потокам чекати одне одного. Поки всі
сторони не прибудуть, блоки методу await чекають. Можна сміливо сказати, що
це інверсія Class CountDownLatch. Це продовжується після того, як N очікує.

Class Exchanger (Обмінник)
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Exchanger.html
У ТОЧЦІ, в якій два потоки можуть ОБМІНЮВАТИСЯ інформацією, Class Exchanger
діє як точка синхронізації. Поки що його аналог(обмінник) не надасть свою
інформацію, потоки блокуються. Таку ж поведінку можна спостерігати з обох боків.

Class Phaser (Фазер)
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Phaser.html
Подібно Class CountDownLatch та Class CyclicBarrier, Class Phaser представляє
собою багаторазовий бар'єр, але пропонує велику гнучкість. Кількість
зареєстрованих сторін не фіксується під час створення в Class Phaser.


Class CountDownLatch vs Class CyclicBarrier в Java
-----------------------------------------------------
Class CountDownLatch та Class CyclicBarrier є допоміжними засобами
синхронізації в паралелізмі Java, які полегшують взаємодію між потоками.
Обидва ці засоби синхронізації створюють клямку або бар'єр, що змушує потоки
чекати, доки не буде виконана умова, після чого лише потоки можуть рухатися далі.

Class CyclicBarrier - допоміжний засіб синхронізації, що дозволяє всім потокам
чекати один одного для досягнення загальної точки бар'єру.
Class CountDownLatch - засіб синхронізації, який дозволяє одному або декільком
потокам чекати завершення набору операцій, які виконуються в інших потоках.

Ініціалізація.
Class CountDownLatch ініціалізується заданим лічильником, де count означає
кількість викликів countDown(), раніше ніж потоки зможуть пройти через await().
Class CyclicBarrier ініціалізується із заданою кількістю сторін, де сторона
(party) позначає кількість потоків, а Class CyclicBarrier спрацьовує, коли
на нього чекає задана кількість сторін (потоків).

Повторне використання.
Одна з основних відмінностей між Class CountDownLatch та Class CyclicBarrier
полягає в тому, що Class CountDownLatch не можна використовувати повторно.
Як тільки лічильник екземпляра Class CountDownLatch досяг нуля, його не можна
скинути.
Class CyclicBarrier можна повторно використовувати після звільнення очікуваних
потоків.

Optional Runnable (Необов'язковий запуск).
Class CyclicBarrier має конструктор, у якому може бути надано
Runnable бар'єрну дію

public CyclicBarrier(int parties, Runnable barrierAction)

Задана дія бар'єра виконується, коли бар'єр вимкнено, виконаний останнім
потоком, що входить до бар'єру. Таким чином, є можливість виконати окрему дію
Runnable за допомогою Class CyclicBarrier.
Class CountDownLatch в Java не має такого конструктора для вказівки виконуваної
дії.


РЕСУРСИ:
https://www.baeldung.com/java-semaphore
https://www.baeldung.com/java-countdown-latch
https://www.baeldung.com/java-concurrent-locks
https://www.baeldung.com/java-cyclic-barrier
https://www.baeldung.com/java-cyclicbarrier-countdownlatch
https://www.baeldung.com/java-exchanger
https://www.baeldung.com/java-phaser

