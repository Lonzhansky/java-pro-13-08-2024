
Створюється певна кількість потоків, серед
цих потоків використовується загальний список ArrayList.

Всі ці потоки обробляють деякі дані та розташовують
результати в ArrayList.

Подальша обробка повинна розпочатися лише після того,
як усі три потоки закінчать роботу та викличуть функцію await().

Для цього використовуємо Class CyclicBarrier, ініціалізований
певним значенням, а також виконувана дія для подальшої обробки.


КОЛИ метод await() Class CyclicBarrier викликається
для поточного потоку, а поточний потік НЕ є останнім,
він ВІДКЛЮЧАЄТЬСЯ з метою планування потоків і БЕЗДІЄ
ДО тих пір, поки не станеться ОДНО З наступних подій:
- Приходить останній потік;
- Якийсь інший потік перериває поточний потік;
- Якийсь інший потік перериває один з інших очікуваних потоків;
- Таймаут деяких інших потоків в очікуванні бар'єру;
- Якийсь інший потік викликає reset() для цього бар'єру.


ЯКЩО у конструкторі було вказано non-null бар'єрну дію,
то поточний потік виконує цю дію, перш ніж дозволити
іншим потокам продовжити роботу.

ЯКЩО під час дії бар'єру виникає ВИНЯТОК, то цей
виняток буде поширено в поточному потоці, і бар'єр
буде переведений у зламаний стан.


BrokenBarrierException у CyclicBarrier
----------------------------------------
ЯКЩО якийсь потік буде перерваний під час очікування
в точці бар'єру, ТО всі інші потоки, що очікують, викличуть
виняток BrokenBarrierException, і бар'єр буде переведено
у зламаний стан.

ЯКЩО бар'єр скидається, reset(), під час очікування будь-якого
потоку викидається BrokenBarrierException.


