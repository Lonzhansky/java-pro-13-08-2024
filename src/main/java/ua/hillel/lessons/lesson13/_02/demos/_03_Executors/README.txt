
Executors
============

Executors (Виконавці) визначають високорівневий API для
запуску потоків та управління ними. Реалізації виконавців,
що надаються java.util.concurrent, забезпечують управління
пулом потоків, що підходить для великих програм.

В невеликих програмах можна реалізувати функціонал, де існує
тісний зв'язок між завданням, що виконується новим потоком,
як визначено його об'єктом Interface Runnable, і самим потоком,
як визначено об'єктом Class Thread. Це добре працює.

Об'єкти Class Thread потребують значного обсягу пам'яті.
Якщо постійно створювати багато таких об'єктів у великій програмі,
це призведе до суттєвих витрат пам'яті.

В великих додатках є сенс відокремити управління та створення
потоків від решти програми. Об'єкти, що інкапсулюють ці функції,
відомі як Виконавці (Executors).


Executor Framework містить набір компонентів, що використовуються
для ефективного керування потоками. Executor Framework є реалізацією
шаблону Producer-Consumer (Виробник-Споживач).

Шаблон Producer-Consumer - це шаблон проектування паралелізму,
в якому один або кілька потоків-виробників створюють об'єкти,
які ставляться в чергу, а потім споживаються одним чи кількома
потоками-споживачами. Об'єкти, поставлені в чергу, часто
є деякою роботою, яку необхідно виконати.
Відділення виявлення роботи від виконання роботи означає, що ви
можете контролювати, скільки потоків одночасно беруть участь у
виявленні або виконанні роботи.

Executor Framework пропонує:

Interface Executor - простий інтерфейс, який містить метод execute()
для запуску завдання, заданого об'єктом Interface Runnable, що запускається.
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html

Interface ExecutorService, який є суб-інтерфейсом Interface Executor,
додає функціональність для керування життєвим циклом потоків.
Він також включає метод submit(), який аналогічний методу execute(),
але універсальніший.
Перевантажені версії методу submit() можуть приймати як виконуваний
(Runnable), і викликаний (Callable) об'єкт.
Об'єкти, що викликаються аналогічні виконуваним, за тим винятком,
що завдання, визначене об'єктом, що викликається, також може
повертати значення. Тому, якщо ми передаємо об'єкт Callable
методом submit(), він повертає об'єкт Future. Цей об'єкт можна
використовувати для отримання значення Callable, що повертається,
і управління статусом як Callable, і Runnable завдань.
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html

Interface ScheduledExecutorService, який є суб-інтерфейсом
Interface ExecutorService. Він додає функціональність, яка дозволяє
планувати виконання завдань у коді.
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html

Class Executors, який за умовчанням включає методи для створення
різних типів служб-виконавців.
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html


За допомогою Class Executors та вищезгаданих інтерфейсів
можна створювати пули потоків.

ПУЛ ПОТІКІВ - це набір об'єктів Interface Runnable і постійно працюючих
потоків. Колекція об'єктів Interface Runnable називається робочою чергою.
Постійно запущені потоки перевіряють робочий запит на наявність
нової роботи, і якщо нова робота має бути виконана, то з
робочої черги буде запущено об'єкт Interface Runnable.

Щоб використати Executor Framework, потрібно створити пул потоків
та відправити туди завдання для виконання. Class Executors має методи,
які використовуються для створення пулів потоків.


ТИПИ ВИКОНАВЦІВ.

SingleThreadExecutor - виконавець пулу потоків, який має лише
один потік. Використовується для виконання завдань.
Якщо потік помирає через виняток під час виконання завдання,
створюється новий потік для заміни старого потоку, а наступні
завдання виконуються в новому.

ExecutorService executorService = Executors.newSingleThreadExecutor()


FixedThreadPool(n) - пул потоків із фіксованою кількістю потоків
(це число зазвичай є загальна кількість потоків, що підтримуються
базовим процесором). Завдання, передані виконавцю, виконуються n потоками,
і якщо завдань більше, вони зберігаються в LinkedBlockingQueue.
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedBlockingQueue.html

ExecutorService executorService = Executors.newFixedThreadPool(3);


CachedThreadPool - пул потоків переважно використовується там, де
необхідно виконати безліч короткострокових паралельних завдань.
На відміну від фіксованого пулу потоків, кількість потоків цього
пулу виконавців не обмежено. Якщо всі потоки зайняті виконанням
якихось завдань і приходить нове завдання, пул створить і додасть
виконавцю новий потік. Як тільки один із потоків звільниться, він
приступить до виконання нових завдань. Якщо потік не діє протягом
шістидесяти секунд, він завершується і видаляється з кешу.

ExecutorService executorService = Executors.newCachedThreadPool();


ScheduledExecutor - виконавець, який використовується, коли маємо
завдання, що необхідно запускати через рівні проміжки часу, або якщо
хочемо відкласти виконання певного завдання.

ScheduledExecutorService scheduledExecService = Executors.newScheduledThreadPool(1);

Завдання можна планувати в ScheduledExecutor, використовуючи
будь-який з методів: scheduleAtFixedRate або scheduleWithFixedDelay.

scheduledExecService.scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)

scheduledExecService.scheduleWithFixedDelay(Runnable command, long initialDelay, long period, TimeUnit unit)

Основна різниця між цими двома методами полягає у їх інтерпретації
затримки між послідовними виконаннями запланованого завдання.

scheduleAtFixedRate виконує завдання з фіксованим інтервалом,
незалежно від того, коли закінчилося попереднє завдання.

scheduleWithFixedDelay запустить зворотний відлік затримки тільки
після завершення поточного завдання.



Interface Future<V>
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html

До результату завдання, переданого на виконання виконавцю, можна
отримати доступ за допомогою об'єкта java.util.concurrent.Future,
яке повертається виконавцем.

Interface Future можна розглядати як обіцянку, дану викликаючій стороні
виконавцем.

Future<String> result = executorService.submit(callableTask);

Завдання, передане виконавцю (див. вище), є асинхронним,
тобто виконання програми не очікує завершення виконання завдання,
щоб перейти до наступного кроку. Замість цього щоразу, коли
виконання завдання завершується, воно встановлюється виконавцем
у цьому об'єкті Interface Future.

Викликаючий може продовжити виконання основної програми, і коли
знадобиться результат відправленого завдання, він може викликати
.get() для цього об'єкта Interface Future.
Якщо завдання завершено, результат негайно повертається об'єкту,
що викликає, в іншому випадку викликаючий об'єкт блокується доти,
доки його виконання не завершиться виконавцем і не буде обчислено
результат.

Якщо викликаюча сторона не може дозволити собі нескінченно чекати
перед отриманням результату, це очікування також може бути розраховано
по часу.
Це досягається за допомогою методу
Future.get(long timeout, TimeUnit unit),
який генерує виняток TimeoutException, якщо результат не
повертається у вказаний період часу. Викликаючий може обробити
цей виняток та продовжити подальше виконання програми.

Якщо під час виконання завдання виникає виняток, виклик методу
get() викличе виняток ExecutionException.


ЗАУВАЖЕННЯ.

Не ставте в чергу завдання, які в цей час чекають на результати
з інших завдань. Це може призвести до безвиході.

Пул потоків після закінчення роботи має бути явно завершений
шляхом виклику методу shutdown().
Якщо цього не зробити, програма продовжуватиме працювати без кінця.
Якщо ви відправите виконавцю інше завдання після завершення роботи,
вона видасть виняток RejectedExecutionException.

Будьте обережні, застосовуючи потоки для тривалих операцій.
Це може привести до нескінченного очікування потоку і зрештою
- до витоку ресурсів.

Для ефективного налаштування пулу потоків необхідно розуміти
особливості завдань.
Якщо завдання дуже різні, є сенс використовувати різні пули
потоків для різних типів завдань, щоб правильно налаштувати їх.


РЕСУРСИ:
https://docs.oracle.com/javase/tutorial/essential/concurrency/exinter.html
https://www.baeldung.com/java-executor-service-tutorial
https://www.baeldung.com/java-single-thread-executor-service
https://www.baeldung.com/java-future


